<html>
<head>
    <title>Ознакомление с классом String</title>
    <style>
		img{
			max-width: 99%;
		}
		body{
			max-width:99%;
		}
		@font-face{
			font-family: "secon";
			src: url("secon.ttf");
		}
		h1,h2,p{
			font-family:"secon";
		}
    </style>
</head>
<body>
	<h1>Наследование классов, интерфейсов, методов и конструкторов</h1>
	<p>
		Наследование — это процесс перенимания классом свойств (методов и полей) другого класса. С использованием в Java наследования информация становится управляемой в иерархическом порядке.

		Класс, который наследует свойства другого класса, называется подклассом (производным классом, наследующим классом), а класс, свойства которого наследуются, известен как суперкласс (базовый класс, родительский класс)
	</p>
	<h1>Ключевое слово extends</h1>
	<p>
		extends — это кодовое слово, используемое для наследования свойств класса. Взглянем на синтаксис этого ключевого слова.
	</p>
	<h2>Синтаксис</h2>
	<div><img src="1.jpg"></div>
	<h2>Пример кода</h2>
	<p>
		Дальше приведён пример процесса наследования на Java. На этом примере Вы можете рассмотреть два класса с именами Calculator и My_Calculator.
		<br>Используя ключевое слово extends в Java, My_Calculator перенимает методы addition() и subtraction() класса Calculator.
	</p>
	<div>
		<img src="2.jpg">
	</div>
	<p>
		После запуска программы получим следующий результат:
		<br>Сумма чисел: 30
		<br>Разность чисел: -10
		<br>Произведение чисел: 200
	</p>
	<p>
		В данной программе, при создании объекта классу My_Calculator, копия содержимого суперкласса создаётся в нём же. Поэтому, используя объект подкласса, Вы можете получить доступ к членам суперкласса.
	</p>
	<div>
		<img src="3.jpg">
	</div>
	<p>
		Ссылочная переменная суперкласса может содержать объект подкласса, но, используя эту переменную, Вы можете иметь доступ только к членам суперкласса, поэтому, чтобы иметь доступ к членам обоих классов, рекомендуется всегда создавать ссылочную переменную к подклассу.

		<br>Обращаясь к программе выше, Вы можете создать экземпляр класса, как в примере ниже. Но, используя ссылочную переменную суперкласса, Вы не можете вызвать метод multiplication(), который принадлежит подклассу My_Calculator.
	</p>
	<div>
		<img src="4.jpg">
	</div>
	<p>
		Примечание: подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса. в Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.
	</p>
	<h1>Ключевое слово super</h1>
	<p>
		Ключевое слово super схоже с ключевым словом this. Ниже приведены случаи, где используется super в Java.
		<br>• Для дифференциации членов суперкласса от членов подкласса, если у них есть одинаковые имена.
		<br>• Для вызова конструктора суперкласса из подкласса.
	</p>
	<h2>Дифференциация членов</h2>
	<p>
		Если класс перенимает свойства другого класса, и члены суперкласса имеют те же имена, что и в подклассе, для их разделения мы используем ключевое слово super, как показано ниже.
	</p>
	<div>
		<img src="5.jpg">
	</div>
	<h2>Пример кода</h2>
	<p>
		Этот раздел содержит программу, которая демонстрирует использование ключевого слова super в Java.

		<br>В предложенной программе у вас есть два класса с именами Sub_class и Super_class, оба имеющие метод display() с разными реализациями и переменную с именем num с разными значениями. Вы можете увидеть, что мы использовали ключевое слово super для дифференциации членов суперкласса из подкласса.
	</p>
	<div>
		<img src="6.jpg">
	</div>
	<p>
		После запуска программы будет получен следующий результат:
		<br>Это метод display() подкласса
		<br>Это метод display() суперкласса
		<br>Значение переменной num в подклассе: 77
		<br>Значение переменной num в суперклассе: 88
	</p>
	<h2>Вызов конструктора суперкласса</h2>
	<p>
		Если класс перенимает свойства другого класса, подкласс автоматически получается стандартный конструктор суперкласса. Но если Вы хотите вызвать параметризованный конструктор суперкласса, Вам нужно использовать ключевое слово super, как показано ниже.
	</p>
	<div>
		<img src="7.jpg">
	</div>
	<h2>Пример кода</h2>
	<p>
		В предложенной программе демонстрируется использование в Java ключевого слова super для вызова параметризованного конструктора. В этой программе содержится суперкласс и подкласс, где суперкласс содержит параметризованный конструктор, который принимает строковое значение, а мы используем ключевое слово super для вызова параметризованного конструктора суперкласса.
	</p>
	<div>
		<img src="8.jpg">
	</div>
	<p>
		После запуска программы будет выдан результат:
		<br>Значение переменной age в суперклассе равно: 24
	</p>
	<h1>Отношение IS-A</h1>
	<p>
		IS-A — это способ сказать «Этот объект является типом этого объекта». Давайте посмотрим, как ключевое слово extends используется для достижения наследования.
	</p>
	<div>
		<img src="9.jpg">
	</div>
	<p>
		Теперь, основываясь на примере выше, в объектно-ориентированных терминах, следующие утверждения верны
		<br>• Animal является суперклассом класса Mammal.
		<br>• Animal является суперклассом класса Reptile.
		<br>• Mammal и Reptile являются подклассами класса Animal.
		<br>• Dog одновременно является подклассом классов Mammal и Animal.
		<br>Теперь, используя отношение IS-A, мы можем сказать так:
		<br>• Mammal IS-A Animal.
		<br>• Reptile IS-A Animal.
		<br>• Dog IS-A Mammal.
		<br>• Таким образом, Dog IS-A тоже Animal.
		<br><br>С использованием ключевого слова extend, подклассы могут наследовать все свойства суперкласса кроме его приватных свойств (private).
		<br><br>Мы можем убедиться, что Mammal на самом деле Animal с использованием оператора экземпляра.
	</p>
	<div>
		<img src="10.jpg">
	</div>
	<p>
		Мы получим следующий результат:
		<br>true
		<br>true
		<br>true
		<br>Так как у нас есть хорошее понимание принципа работы ключевого слова extends, давайте рассмотрим, как используется ключевое слово implements для получения отношения IS-A.
		<br>В общем, ключевое слово implements в Java используется с классами для перенятия свойств интерфейса. Интерфейсы никогда не могут быть переняты классом с помощью extends.
	</p>
	<h2>Пример</h2>
	<div>
		<img src="11.jpg">
	</div>
	<h1>Ключевое Слово instanceof</h1>
	<p>
		Давайте использует оператор instanceof в Java с целью проверки, являются ли Mammal и Dog на самом деле Animal.
	</p>
	<h2>Пример</h2>
	<div>
		<img src="12.jpg">
	</div>
	<p>
		Мы получим следующий результат:
		<br>true
		<br>true
		<br>true
	</p>
	<h1>Отношение HAS-A</h1>
	<p>
		Эти отношения в основном основаны на обращении. Они определяют, является ли определенный класс HAS-A определенным случаем. Эта взаимосвязь помогает уменьшить дублирование кода, а также баги. Взглянем на пример.
	</p>
	<div>
		<img src="13.jpg">
	</div>
	<p>
		Мы видим, что у класса Van HAS-A (есть) Speed. Имея отдельный класс Speed, нам не нужно вставлять код, принадлежащий Speed в класс Van, что позволяет нам использовать класс Speed в нескольких приложениях
		<br><br>В особенности объектно-ориентированного программирования, пользователям не нужно волноваться о том, какой объект выполняет текущую работу. Для достижения этого, класс Van скрывает детали реализации от пользователей класса Van.
		<br>Таким образом, пользователи, должны попросить класс Van выполнить определенное действие, и класс Van либо выполнит работу сам по себе, либо попросит другой класс выполнить действие.
	</p>
	<h1>Виды наследования</h1>
	<p>
		Есть различные способы наследования, как показано ниже.
	</p>
	<div>
		<img src="14.jpg">
	</div>
	<p>
		Очень важно запомнить, что Java не поддерживает множественное наследование. Это значит, что класс не может продлить более одного класса. Значит, следующее утверждение НЕВЕРНО:
	</p>
	<div>
		<img src="15.jpg">
	</div>
	<p>
		Тем не менее, класс может реализовать один или несколько интерфейсов, что и помогло Java избавиться от невозможности множественного наследования.
	</p>
	<h1>Переопределение (overriding)</h1>
	<p>
		Если класс наследует метод из своего суперкласса, тогда есть шанс переопределить взятый метод, если он не помечен final.
		<br>Так что такое в Java overriding или override – это переопределение.
		<br>Преимущество в Java переопределения заключается в том, что оно позволяет определять (описывать) поведение, характерное для типа подкласса, значит подкласс может реализовать метод родительского класса на основе его требования.
		<br>В объектно-ориентированных терминах, переопределение значит перезапись функционала существующего метода.
	</p>
	<h2>Пример 1</h2>
	<div>
		<img src="16.jpg">
	</div>
	<p>
		После запуска программы будет выдан такой результат:
		<br>Животные могут двигаться
		<br>Собаки могут ходить и бегать
		<br><br>В вышеприведённом примере вы можете заметить, что b хоть и является типом Animal, оно запускает метод move в классе Dog. Причина тому: во время компиляции проходит проверка ссылочного типа. Однако, во время выполнения, JVM определяет тип объекта и запускает метод, который принадлежит этому конкретному объекту.
		<br><br>Следовательно, по примеру выше, программа запустится правильно, так как класс Animal имеет метод move. Затем, во время выполнения, он запускает метод, принадлежащий этому объекту.
	</p>
	<h2>Пример 2</h2>
	<div>
		<img src="17.jpg">
	</div>
	<p>
		Программа выдаст ошибку во время компиляции, так как ссылочный тип b у Animal не имеет метода под именем bark.
	</p>
	<h1>Правила переопределения метода</h1>
	<p>
		<br>• Список аргументов должен быть точно таким же, как и для переопределённого метода.
		<br>• Возвращаемый тип должен быть таким же или подтипом возвращаемого типа, объявленного в исходном переопределенном методе в суперклассе.
		<br>• Уровень доступа не может быть более ограниченным, чем уровень доступа переопределённого метода. Например, если метод суперкласса объявлен public, то переопределяемый метод в подклассе не может быть private или protected.
		<br>• Методы экземпляров могут быть переопределены только если они наследованы подклассом.
		<br>• Методы, которые объявлены как final, не могут быть переопределены.
		<br>• Статические методы, которые объявлены как static, не могут быть переопределены, но могут быть повторно объявлены.
		<br>• Если метод нельзя наследовать, то его нельзя переопределить.
		<br>• Подкласс внутри того же пакета, что и суперкласс экземпляра, может переопределять любой метод суперкласса, который не объявлен как private или final.
		<br>• Подкласс в другом пакете может переопределять только не final методы, объявленные как public или protected.
		<br>• Переопределяемый метод может выдавать любые непроверенные исключения вне зависимости от того, переопределяет ли переопределённый метод какие-либо непроверенные исключения или нет. Однако, переопределяемый метод не должен генерировать проверенные исключения, которые являются новыми или более широкими, чем те, которые объявлены переопределённым методом. Переопределенный метод может генерировать более узкие или меньшие исключения, чем переопределенный метод.
		<br>• Конструкторы нельзя переопределить.
	</p>
	<h1>Использование ключевого слова super</h1>
	<p>
		Вызывая версию суперкласса переопределённого метода, используется ключевое слово super.
	</p>
	<h2>Пример</h2>
	<div>
		<img src="18.jpg">
	</div>
	<p>
		После запуска программы будет выдан такой результат:
		<br>Животные могут двигаться
		<br>Собаки могут ходить и бегать
	</p>
</body>
</html>