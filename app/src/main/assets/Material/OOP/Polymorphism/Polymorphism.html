<html>
<head>
    <title>Ознакомление с классом String</title>
    <style>
		img{
			max-width: 99%;
		}
		body{
			max-width:99%;
		}
		@font-face{
			font-family: "secon";
			src: url("secon.ttf");
		}
		h1,h2,p{
			font-family:"secon";
		}
    </style>
</head>
<body>
	<h1>Полиморфизм</h1>
	<p>
		Полиморфизм – способность объекта принимать множество различных форм. Наиболее распространенное использование полиморфизма в ООП происходит, когда ссылка на родительский класс используется для ссылки на объект дочернего класса. Постараемся разобраться с понятием полиморфизма в Java простыми словами, так сказать для чайников.
		<br><br>Любой объект в Java, который может пройти более одного теста IS-A считается полиморфным. В Java все объекты полиморфны, так как любой объект пройдёт тест IS-A для своего собственного типа и для класса Object.
		<br><br>Важно знать, что получить доступ к объекту можно только через ссылочную переменную. Ссылочная переменная может быть только одного типа. Будучи объявленной, тип ссылочной переменной изменить нельзя.
		<br><br>Ссылочную переменную можно переназначить к другим объектам, которые не объявлены как final. Тип ссылочной переменной определяет методы, которые она может вызвать на объекте.
		<br><br>Ссылочная переменная может обратиться к любому объекту своего объявленного типа или любому подтипу своего объявленного типа. Ссылочную переменную можно объявить как класс или тип интерфейса.
	</p>
	<h2>Пример 1</h2>
	<p>
		Рассмотрим пример наследования полиморфизм в Java.
	</p>
	<div><img src="1.jpg"></div>
	<p>
		Теперь класс Deer (Олень) считается полиморфным, так как он имеет множественное наследование. Следующие утверждения верны для примера выше:
		<br>• A Deer IS-A Animal (олень - это животное);
		<br>• A Deer IS-A Vegetarian (олень - это вегетарианец);
		<br>• A Deer IS-A Deer (олень - это олень);
		<br>• A Deer IS-A Object (олень - это объект).
		<br>Когда мы применяем факты ссылочной переменной к ссылке на объект Deer (Олень), следующие утверждения верны:
	</p><h2>Пример 2</h2>
	<div><img src="2.jpg"></div>
	<p>
		Все переменные (d, a, v, o) ссылаются к тому же объекту Deer (Олень).
	</p>
	<h1>Виртуальные методы</h1>
	<p>
		В этом разделе рассмотрим, как поведение переопределённых методов в Java позволяет воспользоваться преимуществами полиморфизма при оформлении классов.
		<br><br>Мы уже рассмотрели переопредение методов, где дочерний класс может переопределить метод своего «родителя». Переопределённый метод же скрыт в родительском классе и не вызван, пока дочерний класс не использует ключевое слово super во время переопределения метода.
	</p>
	<h2>Пример</h2>
	<div>
		<img src="3.jpg">
	</div>
	<p>
		Теперь предположим, что мы наследуем класс Employee следующим образом:
	</p>
	<div>
		<img src="4.jpg">
	</div>
	<p>
		Теперь, внимательно изучите программу и попытайтесь предугадать её вывод:
	</p>
	<div>
		<img src="5.jpg">
	</div>
	<p>
		После запуска программы будет выдан такой результат:
	</p>
	<div>
		<img src="6.jpg">
	</div>
	<p>
		Итак, мы создали два объекта Salary. Один использует ссылку Salary, то есть s, а другой использует ссылку Employee, то есть e.
		<br><br>Во время вызова s.mailCheck(), компилятор видит mailCheck() в классе Salary во время компиляции, а JVM вызывает mailCheck() в классе Salary при запуске программы.
		<br><br>mailCheck() в e совсем другое, потому что e является ссылкой Employee. Когда компилятор видит e.mailCheck(), компилятор видит метод mailCheck() в классе Employee.
		<br><br>Во время компиляции был использован mailCheck() в Employee, чтобы проверить это утверждение. Однако во время запуска программы JVM вызывает mailCheck() в классе Salary.
		<br><br>Это поведение называется вызовом виртуальных методов, а эти методы называются виртуальными. Переопределённый метод вызывается во время запуска программы вне зависимости от того, какой тип данных был использован в исходном коде во время компиляции.
	</p>
</body>
</html>